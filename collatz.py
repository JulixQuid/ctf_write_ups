
def collatz(x):
    if x % 2:
        return x//2
    else:
        return 3*x + 1
    
def mod_inverse(a, modulus):
    # Use the extended Euclidean algorithm to find the inverse
    t, new_t = 0, 1
    r, new_r = modulus, a
    while new_r != 0:
        quotient = r // new_r
        t, new_t = new_t, t - quotient * new_t
        r, new_r = new_r, r - quotient * new_r
    if r > 1:
        raise ValueError(f"No modular inverse for {a} modulo {modulus}")
    if t < 0:
        t = t + modulus
    return t

aux = set()
for collatz_counter in range(1000):
    collatz_cycle = collatz_counter
    for _ in range(collatz_cycle):
        collatz_cycle = collatz(collatz_cycle)
        if collatz_cycle == collatz_counter:
            aux.add(collatz_counter)


print(sorted(aux))
inverses = []
for i in range(1,272):#[6, 9, 13, 19, 24, 33, 36, 40, 49, 54, 60, 67, 73, 81, 90, 109, 121, 135, 163, 181, 271]:
    try:
        aux = mod_inverse(i, 2**2048)
        inverses.append(aux)
    except:
        continue

mf = 10118746134548103012155746101486828202442159361623475716336338166910287136628276962153444214690697196956670856951133973405749881676836763046695227262013613607585130678341052405504663305749605585734425693387122455378893036892277936484189941692545896379985650361392238904088824573908184393393068289733659275115451312997643709983667086891133670195045780152711892703860839366375117551975727392705557911230078317509653464825258695312703261480638346858331165044141219020052266319529675532454619416707391848528898301394334120734308355023719173054373983266681556682814581301528609155918480345410942895730624046671314155686927
print(10118746134548103012155746101486828202442159361623475716336338166910287136628276962153444214690697196956670856951133973405749881676836763046695227262013613607585130678341052405504663305749605585734425693387122455378893036892277936484189941692545896379985650361392238904088824573908184393393068289733659275115451312997643709983667086891133670195045780152711892703860839366375117551975727392705557911230078317509653464825258695312703261480638346858331165044141219020052266319529675532454619416707391848528898301394334120734308355023719173054373983266681556682814581301528609155918480345410942895730624046671314155686927>2**2048)
for i in inverses:
    flag = (mf*i)%2**2048
    flag_bytes = flag.to_bytes((flag.bit_length() + 7) // 8, byteorder='big')
    try:
        decoded_string = flag_bytes.decode()
        print(f"Decoded string: {decoded_string}")
    except UnicodeDecodeError as e:
        continue #print(flag_bytes)
